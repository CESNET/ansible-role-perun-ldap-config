# # # # ################################  Custom schema application part #############

- name: "Check, if the directory exist"
  ansible.builtin.stat:
        path: "/tmp/schems/"
  register: directory

- name: "Create directory"
  ansible.builtin.file:
        path: "/tmp/schems/"
        state: directory
        owner: root
        group: root 
        mode: '0777'
  when: not directory.stat.exists

- name: "Download schema1 file"
  when: not directory.stat.exists
  get_url:
        url: "https://gitlab.ics.muni.cz/perun/perun-idm/perun/-/raw/main/perun-utils/ldapc-scripts/schemas/inetUser-schema.ldif"
        dest: "/tmp/schems/inetUser-schema.ldif"
        owner: root
        group: root 
        mode: '0777'
        force: yes
  register: schemafile1


- name: "Download schema2 file"
  when: not directory.stat.exists
  get_url:
        url: "https://gitlab.ics.muni.cz/perun/perun-idm/perun/-/raw/main/perun-utils/ldapc-scripts/schemas/perun-schema.ldif"
        dest:  "/tmp/schems/perun-schema.ldif"
        force: yes
        owner: root
        group: root 
        mode: '0777'
  register: schemafile2
  
- name: "Download schema3 file"
  when: not directory.stat.exists
  get_url:
        url: "https://gitlab.ics.muni.cz/perun/perun-idm/perun/-/raw/main/perun-utils/ldapc-scripts/schemas/tenOperEntry-schema.ldif"
        dest:  "/tmp/schems/tenOperEntry-schema.ldif"
        force: yes
        owner: root
        group: root 
        mode: '0777'
  register: schemafile3
  
- name: "Run script for changes schemas from Open to 389"
  ansible.builtin.shell: |
        python3 -c "
        import os
        import re

        # Way to directory
        input_directory = '.'
        # Way to directory, where will be saved new files
        output_directory = '.'

        # Name of attributes, need to be comment
        search_strings = ['1.3.6.1.4.1.8057.2.80.35', '1.3.6.1.4.1.8057.2.80.48']  # Change 'RETAZEC1', 'RETAZEC2', 'RETAZEC3' to what you need to comment

        print('Step X finish')

        # Create output directory if it does not exist
        os.makedirs(output_directory, exist_ok=True)

        # Browse all files in a folder
        for filename in os.listdir(input_directory):
            if filename.endswith('.ldif'):
                input_file_path = os.path.join(input_directory, filename)
                # Set 389 to the name of the file
                base, ext = os.path.splitext(filename)
                output_file_path = os.path.join(output_directory, f'{base}389{ext}')

                # Load the contents of the file
                with open(input_file_path, 'r') as input_file:
                    input_string = input_file.readlines()

                # Process strings and comment out lines containing any of the search strings
                updated_lines = []
                for line in input_string:
                    if any(search_string in line for search_string in search_strings):
                        updated_lines.append('#' + line)
                    else:
                        updated_lines.append(line)

                # Merging strings back into one
                cleaned_string = ''.join(updated_lines)

                # Change header to 'dn: cn=schema'
                cleaned_string = re.sub(r'dn:.*', 'dn: cn=schema', cleaned_string)

                # Removing 'olc' and text in square brackets including them
                cleaned_string = cleaned_string.replace('olc', '')
                cleaned_string = re.sub(r'\s*\{.*?\}', '', cleaned_string)

                # Replacing 'replace:' with 'add:'
                cleaned_string = cleaned_string.replace('replace:', 'add:')

                # Saving the resulting string to a file
                with open(output_file_path, 'w') as output_file:
                    output_file.write(cleaned_string)

                print(f'Edited file saved as: {output_file_path}')

        print('FINISH')
        "

  args:
      chdir: /tmp/schems
  register: result

- name: "Check if was schema inetUser already applied"
  shell:
    cmd: >-  
      ldapsearch -x -D "{{ ldap_ds389_root_dn }}" -w "{{ ldap_ds389_root_pass }}" 
        -H "ldaps://{{ ldap_ds389_server_name }}:636" 
        -s base  -b "cn=schema" '+' '*' | grep inetUserHttpURL
  register: applied_schemas1
  ignore_errors: true 

- name: "Chcek if was schema Perun already applied"
  shell:
    cmd: >-
      ldapsearch -x -D "{{ ldap_ds389_root_dn }}" -w "{{ ldap_ds389_root_pass }}" 
        -H "ldaps://{{ ldap_ds389_server_name }}:636" 
        -s base  -b "cn=schema" '+' '*' | grep perunResource
  register: applied_schemas2
  ignore_errors: true 

- name: "Chcek if was schema tenOperEntry already applied"
  shell:
    cmd: >-
      ldapsearch -x -D "{{ ldap_ds389_root_dn }}" -w "{{ ldap_ds389_root_pass }}" 
        -H "ldaps://{{ ldap_ds389_server_name }}:636" 
        -s base  -b "cn=schema" '+' '*' | grep sponsorshipApprovedUntil
  register: applied_schemas3
  ignore_errors: true 

- name: "Applying schemas"
  block:
      - name: "applying schema1" 
        when: "applied_schemas1.rc == 0"
        shell:
          cmd: >-
            ldapmodify -x -D "{{ ldap_ds389_root_dn }}" -w "{{ ldap_ds389_root_pass }}"
              -H "ldaps://{{ ldap_ds389_server_name }}:636" -f "/tmp/schems/inetUser-schema389.ldif"
      - name: "applying schema2" 
        when: "applied_schemas2.rc == 1"
        shell:
          cmd: >-
           ldapmodify -x -D "{{ ldap_ds389_root_dn }}" -w "{{ ldap_ds389_root_pass }}"    
             -H "ldaps://{{ ldap_ds389_server_name }}:636" -f "/tmp/schems/perun-schema389.ldif"
      - name: "applying schema3" 
        when: "applied_schemas3.rc == 1"
        shell:
          cmd: >-
            ldapmodify -x -D "{{ ldap_ds389_root_dn }}" -w "{{ ldap_ds389_root_pass }}"
              -H "ldaps://{{ ldap_ds389_server_name }}:636" -f "/tmp/schems/tenOperEntry-schema389.ldif"
        register: applied_schemas_files

- name: "Restart 389 DS"
  when: applied_schemas_files.changed
  systemd:
          name: dirsrv@{{ ldap_ds389_instance_name }} 
          state: restarted
          enabled: yes  

- name: "Set the maxbersize on 16MB"
  shell: |
        ldapmodify -x -D "{{ ldap_ds389_root_dn }}" -w "{{ ldap_ds389_root_pass }}" <<EOF
        dn: cn=config
        changetype: modify
        replace: nsslapd-maxbersize
        nsslapd-maxbersize: 16777216
        EOF

- name: "Change ACI when not"         
  community.general.ldap_attrs:
     dn: "{{ ldap_ds389_basedn }}"
     bind_dn: "{{ ldap_ds389_root_dn }}"
     bind_pw: "{{ ldap_ds389_root_pass }}"
     server_uri: "ldaps://{{ ldap_ds389_server_name }}:636"
     attributes: 
       aci: 
          "{{ ldap_ds389_aci_content }}"
     state: exact

